# オブジェクト指向プログラミングを語れるようになろう
## オブジェクト指向プログラミングとは？

**オブジェクト指向プログラミング（OOP=Object Oriented Programming）**

大規模なプログラムの開発を効率化し、さらに保守を容易にすることを目的とする。

プログラムを効率的に開発して保守も容易にできるなら、コスト（開発費＋保守費）を大幅に削減できる！
一方…
　新たに学習しなければならないことが多い、思うように開発できない…
　面倒臭い！

## OPPに対するさまざまな捉え方

用語辞典などでは
対象（オブジェクト）そのものに重点をおき、対象の振る舞いや操作が
対象の属性として備わるという考え方に基づいてプログラミングすること。
プログラムの再利用が可能となり、ソフトウェアの生産性が高められる。
主なプログラミング・テクニックには、継承、カプセル化、多態性の３つがある。

？？？あんまりよくわからん

オブジェクト指向プログラミングも、プログラマーによってさまざまな捉え方がある。

## 意見１：部品を組み合わせてプログラムを構築することだ

複数のクラスを組み合わせて１つのプログラムを構築する
　→　クラスはプログラムの「部品（コンポーネント）」

オブジェクト指向ではないC言語やBASIC
　関数と変数の集合体
　1000個の関数と2000個の変数が必要であれば、その分だけ定義する
　⇨オブジェクト指向では、関係のある関数と変数をグループ化した「クラス」をつかう。
　　クラスにまとめられた関数と変数を「メンバー」と総称する。

## 意見２：開発効率と保守性を向上するものだ
・「クラスライブラリ」で効率化！
　さまざまなプログラムから利用できる、既存のクラス。
　一から手作りしなくて良い。

・保守範囲が限定的になる！
　関数と変数がクラスによってグルーピングされているため、改修時の範囲が
　限定される。問題のあるクラスだけ、修正すれば良い。

・クラスを作る人と、使う人
　クラスを作る人であれば、全てのクラスを把握する必要はない。
　一部の部品の作成を、協力会社に委託することもできる。
　　クラスを作る人：
　　　プログラムの開発効率と保守性を考慮して、何をクラスにすれば良いかを決める。

・「インターフェース」でクラスの仕様を決める
　具体的な処理内容を記載せず、変数またはメソッドの型を記述したもの。
　部品を使う人にとって、クラスがどのように見えるかという仕様。

## 意見3：大規模なプログラムに適した開発手法だ
・オブジェクト指向プログラミングは人間らしく進歩した手法
　オブジェクト指向プログラミングは大規模なプログラムに適している。
　（クラスの利用しグループ化できる、カプセル化など）
　人間の感覚では、大きな物は部品を組み合わせて作成されるため
　オブジェクト指向プログラミングは、人間の感覚に近いものと言える。

## 意見4：現実世界のモデリングを行うことだ
・「モデリング」
　プログラムに置き換える現実世界を「どのような物（オブジェクト）から構成されているか」
　という観点で分析すること。

・モデリングでは「部品化」と「省略化」を行う
　部品化：現実世界を複数のオブジェクトの集合体として分割する
　省略化：分割された部品から、プログラミングする上で不要なものを省略する

## 意見5：UMLでプログラムを設計することだ
・モデリングを図示する「UML」という表記方法
　「UML(Unified Modeling Language、統一モデリング言語)」という世界標準の表記方法
　９種類の設計書が規定されていて、さまざまな視点から図示できる。
　　・ユースケース図：ユーザー視点
　　・クラス図：プログラマ視点
　⇨９種類の役割さえ覚えれば、オブジェクト指向の考え方を理解できる！

・オブジェクト指向プログラミングのための設計
　変数や関数を考えるのではなく、クラスから決める。
　プログラムの対象となる現実世界をみて
　「どのような物（クラス）から構成されているのか？」を考える。

## 意見６：オブジェクト間のメッセージ・パッシングで
　　　　　プログラムが動作するものだ
・オブジェクトが他のオブジェクトの持つ関数を呼び出すことで、プログラムが動作する
　⇨オブジェクト間の「メッセージ・パッシング」と呼ぶ。

プライヤーAとプレイヤーBがじゃんけんをして勝敗を決める
・ジャッジクラスがプライヤーAクラスの手を問い合わせる
・ジャッジクラスがプレイヤーBクラスの手を問い合わせる
・ジャッジクラスの勝敗判断関数にて、勝敗を決める
⇨ジャッジクラスがプレイヤーAクラスとプレイヤーBクラスの関数を呼び出している。

・手続き型言語：「フローチャート（流れ図）」で表す
　オブジェクト指向：「シーケンス図」「コラボレーション図」で表す

・シーケンス図は、メッセージ・パッシングを表す。
　図の上から下に向かって時間が流れ、オブジェクト間のメッセージ・パッシング
　（プログラムでは関数の呼び出し）を矢印で表す。
 
 
 ## 意見7：継承、カプセル化、多態性を使うことだ
 ・継承（inheritance）
  既存のクラスの持つメンバーを引き継いで新たなクラスを作成すること。
  　メリット：既存のクラスを継承すれば、新たなクラスを効率的に作成できる。
  　　　　　　継承元を修正すれば、継承先にも反映されるため、保守性向上。
        
 ・カプセル化（encapsulation）
  クラスの持つメンバーの中で、クラスの利用者に見せる必要のないものを隠すこと。
  変数はprivateにして、関数をpublicにする。関数経由で変数に値をセットすることができる。
  　メリット：不要なメンバーを隠せば、クラスがブラックボックス化された使いやすい部品となる。
   
 ・多態性（polymorphism）
  同じメッセージに対して複数の操作を行うこと。
  　メリット：同じメッセージで複数の操作が行えるクラスを作れば、クラスを使う人は
   　　　　　覚えることが少なくて済む。
        
  →開発効率と保守性の向上を実現するもの。
  
  ## クラスとオブジェクトの違い
  　・クラス：オブジェクトの定義　→ 鯛焼きの型
  　・オブジェクト：クラスが実体をもったもの（インスタンス）　→ 鯛焼き（中身によってあんこ味やクリーム味になる）
   メモリー上にクラスのコピーを作成して使う。このコピーがオブジェクト。
   
   public class PersonalInfo {
    //名前
    String name;
    //年齢
    int age;
　　}
  
  PersonalInfo p1 = new PersonalInfo();
  
  →メモリの中にPersonalInfoクラスと同じ構造の領域が確保され、その領域をプログラム上でp1と呼ぶことになる。
  　p1はPersonalInfoクラスの構造をしているので、その中にnameとageの領域を持つ。
   
 ## クラスの使い方は3通りある
 　・クラスを作る人：
  　「クラスを定義する」→　再利用生、保守性、現実世界のモデリング、および使いやすさなどを考慮して
   　関数と変数をまとめる。
    
   ・クラスを使う人：　3通りの方法でクラスを使う。
   　1）クラスが持つメンバーを個別に利用する方法
    2）クラスの定義の中に他のクラスを含める方法
    3）既存のクラスを継承して新しいクラスを定義する方法
    
    ・フレームワーク
    OSの複雑さをかくすことで開発を効率化するためのプログラムのセット
    フレームワーク　＝　実行エンジン　＋　クラスライブラリ
